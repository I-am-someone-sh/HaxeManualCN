<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Haxe 中文手册 |  </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"3.类型系统/3.6.类型推断/3.6.1.由上而下推断.html","title":""},"data":{"navigation":{"logo":{"text":"Haxe 中文手册","type":"link","path":"index.html"},"main":[{"text":"目录","type":"label","children":null},{"text":"2.类型","type":"link","path":"2.类型/2.类型.html","children":[{"text":"2.1.基本类型","type":"link","path":"2.类型/2.1.基本类型/2.1.基本类型.html","children":[{"text":"2.1.1.数值类型","type":"link","path":"2.类型/2.1.基本类型/2.1.1.数值类型.html"},{"text":"2.1.2.溢出","type":"link","path":"2.类型/2.1.基本类型/2.1.2.溢出.html"}]},{"text":"2.2.为空性","type":"link","path":"2.类型/2.2.为空性/2.2.为空性.html"},{"text":"2.3.类实例","type":"link","path":"2.类型/2.3.类实例/2.3.类实例.html"},{"text":"2.4.枚举实例","type":"link","path":"2.类型/2.3.类实例/2.4.枚举实例.html"},{"text":"2.5.匿名结构","type":"link","path":"2.类型/2.5.匿名结构/2.5.匿名结构.html","children":[{"text":"2.5.1.结构值的JSON形式","type":"link","path":"2.类型/2.5.匿名结构/2.5.1.结构值的JSON形式.html"},{"text":"2.5.2.结构类型的类记法","type":"link","path":"2.类型/2.5.匿名结构/2.5.2.结构类型的类记法.html"},{"text":"2.5.3.可选字段","type":"link","path":"2.类型/2.5.匿名结构/2.5.3.可选字段.html"},{"text":"2.5.4.性能影响","type":"link","path":"2.类型/2.5.匿名结构/2.5.4.性能影响.html"},{"text":"2.5.5.扩展","type":"link","path":"2.类型/2.5.匿名结构/2.5.5.扩展.html"}]},{"text":"2.6.函数类型","type":"link","path":"2.类型/2.6.函数类型/2.6.函数类型.html"},{"text":"2.7.动态类型","type":"link","path":"2.类型/2.7.动态类型/2.7.动态类型.html"},{"text":"2.8.抽象类型","type":"link","path":"2.类型/2.8.抽象类型/2.8.抽象类型.html"},{"text":"2.9.单形","type":"link","path":"2.类型/2.9.单形/2.9.单形.html"}]},{"text":"3.类型系统","type":"link","path":"3.类型系统/3.类型系统.html","children":[{"text":"3.1.Typedef","type":"link","path":"3.类型系统/3.1.Typedef/3.1.Typedef.html"},{"text":"3.2.类型参数","type":"link","path":"3.类型系统/3.2.类型参数/3.2.类型参数.html"},{"text":"3.3.泛型","type":"link","path":"3.类型系统/3.3.泛型/3.3.泛型.html"},{"text":"3.4.变异","type":"link","path":"3.类型系统/3.4.变异/3.4.变异.html"},{"text":"3.5.一致性检查","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.一致性检查.html","children":[{"text":"3.5.1.类与接口","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.1.类与接口.html"},{"text":"3.5.2.结构子类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.2.结构子类型.html"},{"text":"3.5.3.单形","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.3.单形.html"},{"text":"3.5.4.函数返回","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.4.函数返回.html"},{"text":"3.5.5.通用基本类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.5.通用基本类型.html"}]},{"text":"3.6.类型推断","type":"link","path":"3.类型系统/3.6.类型推断/3.6.类型推断.html"},{"text":"3.7.模块和路径","type":"link","path":"3.类型系统/3.7.模块和路径/3.7.模块和路径.html"}]},{"text":"4.类字段","type":"link","path":"4.类字段/4.类字段.html"},{"text":"5.表达式","type":"link","path":"5.表达式/5.表达式.html"},{"text":"6.语言特性","type":"link","path":"6.语言特性/6.语言特性.html"},{"text":"7.编译器用法","type":"link","path":"7.编译器用法/7.编译器用法.html"},{"text":"8.编译器功能","type":"link","path":"8.编译器功能/8.编译器功能.html"},{"text":"9.宏","type":"link","path":"9.宏/9.宏.html"},{"text":"10.标准库","type":"link","path":"10.标准库/10.标准库.html"},{"text":"支持与反馈","type":"label","children":null},{"text":"Repository Link","type":"link","path":"https://github.com/NulllStack/HaxeManualCN"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Haxe 中文手册</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="3-6-1-由上而下推断"><a href="#3-6-1-由上而下推断" class="headerlink" title="3.6.1.由上而下推断"></a>3.6.1.由上而下推断</h1><p>大多数时候，类型自己被推断，然后可以被统一为一个预期的类型。然而在一些地方，一个预期的类型可能被用来影响推断。然后我们讨论自上而下的推断。</p>
<blockquote>
<p>Most of the time,types are inferred on their own and may then be uniﬁed with an expected type. In a few places,however,an expected type may be used to inﬂuence inference. We then speak of top-down inference.</p>
</blockquote>
<p><strong>预期类型</strong></p>
<blockquote>
<p>定义：预期类型<br> 预期的类型在表达式的类型在它被类型化之前已知的时候出现，例如，因为表达式被看作一个函数调用。它们可以影响这个表达式的类型化，通过所谓的自上而下推断（第3.6.1节）。<br> [warning] Deﬁnition: Expected Type<br> Expected types occur when the type of an expression is known before that expression has been typed, e.g. because the expression is argument to a function call. They can inﬂuence typing of that expression through what is called top-down inference (3.6.1).</p>
</blockquote>
<p>一个很好的例子是混合类型的数组。如在 Dynamic（第2.7节）中提到的，编译器拒绝[1,”foo”]因为它不能确定元素的类型。使用自上而下的推断，这个问题可以被克服：</p>
<blockquote>
<p>A good example are arrays of mixed types. As mentioned in Dynamic (Section 2.7), the compiler refuses [1, “foo”] because it cannot determine an element type. Employing top-down inference, this can be overcome:</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">        <span class="keyword">var</span> a:<span class="type">Array</span>&lt;<span class="keyword">Dynamic</span>&gt; = [<span class="number">1</span>, <span class="string">"foo"</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，编译器知道当类型化 [1,”foo”]，预期的类型是 Array，所以元素类型是 Dynamic 。和通常的合一行为不同，编译器会尝试（并失败）去确定一个通用类型（第3.5.5节），个别的元素不利于类型化会被统一为 Dynamic。</p>
<blockquote>
<p>Here,the compiler knows while typing [1, “foo”] that the expected type is Array, so the element type is Dynamic. Instead of the usual uniﬁcation behavior where the compiler would attempt (and fail) to determine a common base type (3.5.5), the individual elements are typed against and uniﬁed with Dynamic.</p>
</blockquote>
<p>在构建泛型类型参数（第3.3.1节）被引入的时候，我们看到了另一个自上而下推断的有趣用法</p>
<blockquote>
<p>We have seen another interesting use of top-down inference when construction of generic type parameters (3.3.1) was introduced:</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> Constructible = &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(s:<span class="type">String</span>):<span class="type">Void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">        <span class="keyword">var</span> s:<span class="type">String </span>= make(); </span><br><span class="line">        <span class="keyword">var</span> t:<span class="type">haxe</span>.Template = make(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@:generic </span></span><br><span class="line">    static function make&lt;T:Constructible&gt;():T &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">T</span>(<span class="string">"foo"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式的类型 String是 被haxe.Template在这里使用的，来确定make的返回类型。这是因为方法调用为 make()，所以我们知道返回类型会分配到变量。利用这个信息，可以分别绑定 unknown 类型 T到 String和 haxe.Template 。</p>
<blockquote>
<p>The explicit types String and haxe.Template are used here to determine the return type of make. This works because the method is invoked as make(),so we know the return type will be assigned to the variables. Utilizing this information, it is possible to bind the unknown type T to String and haxe.Template respectively.3.6.1.由上而下推断</p>
<p>大多数时候，类型自己被推断，然后可以被统一为一个预期的类型。然而在一些地方，一个预期的类型可能被用来影响推断。然后我们讨论自上而下的推断。</p>
<blockquote>
<p>Most of the time,types are inferred on their own and may then be uniﬁed with an expected type. In a few places,however,an expected type may be used to inﬂuence inference. We then speak of top-down inference.</p>
</blockquote>
<p><strong>预期类型</strong></p>
<blockquote>
<p>定义：预期类型<br> 预期的类型在表达式的类型在它被类型化之前已知的时候出现，例如，因为表达式被看作一个函数调用。它们可以影响这个表达式的类型化，通过所谓的自上而下推断（第3.6.1节）。<br> [warning] Deﬁnition: Expected Type<br> Expected types occur when the type of an expression is known before that expression has been typed, e.g. because the expression is argument to a function call. They can inﬂuence typing of that expression through what is called top-down inference (3.6.1).</p>
</blockquote>
<p>一个很好的例子是混合类型的数组。如在 Dynamic（第2.7节）中提到的，编译器拒绝[1,”foo”]因为它不能确定元素的类型。使用自上而下的推断，这个问题可以被克服：</p>
<blockquote>
<p>A good example are arrays of mixed types. As mentioned in Dynamic (Section 2.7), the compiler refuses [1, “foo”] because it cannot determine an element type. Employing top-down inference, this can be overcome:</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">&gt;         <span class="keyword">var</span> a:<span class="type">Array</span>&lt;<span class="keyword">Dynamic</span>&gt; = [<span class="number">1</span>, <span class="string">"foo"</span>]; </span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这里，编译器知道当类型化 [1,”foo”]，预期的类型是 Array，所以元素类型是 Dynamic 。和通常的合一行为不同，编译器会尝试（并失败）去确定一个通用类型（第3.5.5节），个别的元素不利于类型化会被统一为 Dynamic。</p>
<blockquote>
<p>Here,the compiler knows while typing [1, “foo”] that the expected type is Array, so the element type is Dynamic. Instead of the usual uniﬁcation behavior where the compiler would attempt (and fail) to determine a common base type (3.5.5), the individual elements are typed against and uniﬁed with Dynamic.</p>
</blockquote>
<p>在构建泛型类型参数（第3.3.1节）被引入的时候，我们看到了另一个自上而下推断的有趣用法</p>
<blockquote>
<p>We have seen another interesting use of top-down inference when construction of generic type parameters (3.3.1) was introduced:</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">typedef</span> Constructible = &#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(s:<span class="type">String</span>):<span class="type">Void</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">&gt;         <span class="keyword">var</span> s:<span class="type">String </span>= make(); </span><br><span class="line">&gt;         <span class="keyword">var</span> t:<span class="type">haxe</span>.Template = make(); </span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="meta">@:generic </span></span><br><span class="line">&gt;     static function make&lt;T:Constructible&gt;():T &#123; </span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">T</span>(<span class="string">"foo"</span>); </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>显式的类型 String是 被haxe.Template在这里使用的，来确定make的返回类型。这是因为方法调用为 make()，所以我们知道返回类型会分配到变量。利用这个信息，可以分别绑定 unknown 类型 T到 String和 haxe.Template 。</p>
<blockquote>
<p>The explicit types String and haxe.Template are used here to determine the return type of make. This works because the method is invoked as make(),so we know the return type will be assigned to the variables. Utilizing this information, it is possible to bind the unknown type T to String and haxe.Template respectively.</p>
</blockquote>
</blockquote>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
