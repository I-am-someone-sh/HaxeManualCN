<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Haxe 中文手册 |  </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"3.类型系统/3.2.类型参数/3.2.类型参数.html","title":""},"data":{"navigation":{"logo":{"text":"Haxe 中文手册","type":"link","path":"index.html"},"main":[{"text":"目录","type":"label","children":null},{"text":"2.类型","type":"link","path":"2.类型/2.类型.html","children":[{"text":"2.1.基本类型","type":"link","path":"2.类型/2.1.基本类型/2.1.基本类型.html","children":[{"text":"2.1.1.数值类型","type":"link","path":"2.类型/2.1.基本类型/2.1.1.数值类型.html"},{"text":"2.1.2.溢出","type":"link","path":"2.类型/2.1.基本类型/2.1.2.溢出.html"}]},{"text":"2.2.为空性","type":"link","path":"2.类型/2.2.为空性/2.2.为空性.html"},{"text":"2.3.类实例","type":"link","path":"2.类型/2.3.类实例/2.3.类实例.html"},{"text":"2.4.枚举实例","type":"link","path":"2.类型/2.3.类实例/2.4.枚举实例.html"},{"text":"2.5.匿名结构","type":"link","path":"2.类型/2.5.匿名结构/2.5.匿名结构.html","children":[{"text":"2.5.1.结构值的JSON形式","type":"link","path":"2.类型/2.5.匿名结构/2.5.1.结构值的JSON形式.html"},{"text":"2.5.2.结构类型的类记法","type":"link","path":"2.类型/2.5.匿名结构/2.5.2.结构类型的类记法.html"},{"text":"2.5.3.可选字段","type":"link","path":"2.类型/2.5.匿名结构/2.5.3.可选字段.html"},{"text":"2.5.4.性能影响","type":"link","path":"2.类型/2.5.匿名结构/2.5.4.性能影响.html"},{"text":"2.5.5.扩展","type":"link","path":"2.类型/2.5.匿名结构/2.5.5.扩展.html"}]},{"text":"2.6.函数类型","type":"link","path":"2.类型/2.6.函数类型/2.6.函数类型.html"},{"text":"2.7.动态类型","type":"link","path":"2.类型/2.7.动态类型/2.7.动态类型.html"},{"text":"2.8.抽象类型","type":"link","path":"2.类型/2.8.抽象类型/2.8.抽象类型.html"},{"text":"2.9.单形","type":"link","path":"2.类型/2.9.单形/2.9.单形.html"}]},{"text":"3.类型系统","type":"link","path":"3.类型系统/3.类型系统.html","children":[{"text":"3.1.Typedef","type":"link","path":"3.类型系统/3.1.Typedef/3.1.Typedef.html"},{"text":"3.2.类型参数","type":"link","path":"3.类型系统/3.2.类型参数/3.2.类型参数.html"},{"text":"3.3.泛型","type":"link","path":"3.类型系统/3.3.泛型/3.3.泛型.html"},{"text":"3.4.变异","type":"link","path":"3.类型系统/3.4.变异/3.4.变异.html"},{"text":"3.5.一致性检查","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.一致性检查.html","children":[{"text":"3.5.1.类与接口","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.1.类与接口.html"},{"text":"3.5.2.结构子类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.2.结构子类型.html"},{"text":"3.5.3.单形","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.3.单形.html"},{"text":"3.5.4.函数返回","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.4.函数返回.html"},{"text":"3.5.5.通用基本类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.5.通用基本类型.html"}]},{"text":"3.6.类型推断","type":"link","path":"3.类型系统/3.6.类型推断/3.6.类型推断.html"},{"text":"3.7.模块和路径","type":"link","path":"3.类型系统/3.7.模块和路径/3.7.模块和路径.html"}]},{"text":"4.类字段","type":"link","path":"4.类字段/4.类字段.html"},{"text":"5.表达式","type":"link","path":"5.表达式/5.表达式.html"},{"text":"6.语言特性","type":"link","path":"6.语言特性/6.语言特性.html"},{"text":"7.编译器用法","type":"link","path":"7.编译器用法/7.编译器用法.html"},{"text":"8.编译器功能","type":"link","path":"8.编译器功能/8.编译器功能.html"},{"text":"9.宏","type":"link","path":"9.宏/9.宏.html"},{"text":"10.标准库","type":"link","path":"10.标准库/10.标准库.html"},{"text":"支持与反馈","type":"label","children":null},{"text":"Repository Link","type":"link","path":"https://github.com/NulllStack/HaxeManualCN"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Haxe 中文手册</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="3-2-类型参数"><a href="#3-2-类型参数" class="headerlink" title="3.2.类型参数"></a>3.2.类型参数</h1><p>Haxe允许许多类型的参数化，就像类字段（第4章）和枚举构造函数（第2.4.1节）。类型参数通过闭合的尖括号囊括以逗号分隔的类型参数名来定义。一个简单的例子来自于Haxe标准库，就是 Array：</p>
<p><em>Haxe allows parametrization of a number of types, as well as class ﬁelds (4) and enum constructors (2.4.1). Type parameters are deﬁned by enclosing comma-separated type parameter names in angle brackets &lt;&gt;. A simple example from the Haxe Standard Library is Array:</em></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">push</span></span>(x : <span class="type">T</span>) : <span class="type">Int</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个Array的实例被创建，它的类型参数 T 成为一个 单形（第2.9节）。也就是说，它可以被绑定到任何类型，但是一次只有一个。可以是显式地触发绑定，通过调用构造函数并显式地提供类型（<code>new Array&lt;String&gt;()</code>），或者隐式地触发，通过类型推断（第3.6节），例如当我们调用 <code>arrayInstance.push(&quot;foo&quot;)</code> 。</p>
<p><em>Whenever an instance of Array is created, its type parameter T becomes a monomorph (2.9). That is, it can be bound to any type, but only one at a time. This binding can happen</em><br><em>explicitly by invoking the constructor with explicit types (new Array()) or implicitly by type inference (3.6), e.g. when invoking arrayInstance.push(“foo”).</em></p>
<p>在一个类的定义中使用类型参数时，除非加入了约束（第3.2.1节）否则这些类型参数都没有指定特定的类型。因此编译器必须假定这些类型参数可以被分配为任意类型使用。因此，不能访问类型参数的字段或者 类型转换（第5.23）为一个类型参数类型。也不可能为一个类型参数创建新的实例，除非类型参数是泛型（第3.3节）并且被相应的约束。</p>
<p><em>Inside the deﬁnition of a class with type parameters,these type parameters are an unspeciﬁc type. Unless constraints (3.2.1) are added, the compiler has to assume that the type parameters could be used with any type. As a consequence, it is not possible to access ﬁelds of type parameters or cast (5.23) to a type parameter type. It is also not possible to create a new instance of a type parameter type, unless the type parameter is generic (3.3) and constrained accordingly.</em></p>
<p>下面的表格展示了允许声明类型参数的地方：</p>
<p><em>The following table shows where type parameters are allowed:</em></p>
<table>
<thead>
<tr>
<th style="text-align:left">位置</th>
<th style="text-align:left">触发绑定</th>
<th style="text-align:left">注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Class</td>
<td style="text-align:left">实例化</td>
<td style="text-align:left">也可以于成员字段被访问时绑定</td>
</tr>
<tr>
<td style="text-align:left">Enum</td>
<td style="text-align:left">实例化</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Enum构造函数</td>
<td style="text-align:left">实例化</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Function</td>
<td style="text-align:left">调用中</td>
<td style="text-align:left">允许用于方法和命名的局部 lvalue 函数</td>
</tr>
<tr>
<td style="text-align:left">Structure</td>
<td style="text-align:left">实例化</td>
</tr>
</tbody>
</table>
<p>函数类型参数在函数被调用时触发绑定，这样的类型参数（如果无约束）接受任何类型。但是，每次调用只接受一种类型。比如当一个函数有多个参数时：</p>
<p><em>With function type parameters being bound upon invocation, such a type parameter (if unconstrained) accepts any type. However, only one type per invocation is accepted. This can be utilized if a function has multiple arguments:</em></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">        equals(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// runtime message: bar should be foo </span></span><br><span class="line">        equals(<span class="string">"foo"</span>, <span class="string">"bar"</span>); </span><br><span class="line">        <span class="comment">// compiler error: String should be Int</span></span><br><span class="line">        equals(<span class="number">1</span>, <span class="string">"foo"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static function equals&lt;T&gt;(expected:T, actual:T) &#123; </span><br><span class="line">        <span class="keyword">if</span> (actual != expected) &#123;</span><br><span class="line">            <span class="built_in">trace</span>(’$actual should be $expected’); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals</code>函数的 <code>expected</code> 参数和 <code>actual</code> 参数都是类型 <code>T</code> 。这意味着对于每个 <code>equals</code> 的调用，这两个参数必须是相同类型。编译器承认第一个调用（两种参数类型都是 <code>Int</code> ）和第二个调用（两个参数都是 <code>String</code> ），但是第三个调用引发了一个编译器错误。</p>
<p><em>Both of the <code>equals</code> function’s arguments, <code>expected</code> and <code>actual</code>, have type <code>T</code>. This implies that for each invocation of <code>equals</code>, the two arguments must be of the same type. The compiler permits the first call (both arguments being of <code>Int</code>) and the second call (both arguments being of <code>String</code>) but the third attempt causes a compiler error due to a type mismatch.</em></p>
<blockquote>
<p><strong>花絮</strong>：表达式语法中的类型参数<br> 我们常常被问及，为什么一个使用类型参数的方法不能被以 <code>method&lt;String&gt;(x)</code> 形式调用。编译器给出的错误信息不是很有用。这里，有一个简单的解释：上面的代码会把 &lt; 和 &gt; 都解析为二元操作符，结果会解析为 <code>(method&lt; Sting) &gt; (x)</code>。</p>
</blockquote>
<blockquote>
<h5 id="Trivia-Type-parameters-in-expression-syntax"><a href="#Trivia-Type-parameters-in-expression-syntax" class="headerlink" title="Trivia: Type parameters in expression syntax"></a><a href="https://haxe.org/manual/type-system-type-parameters.html#trivia-type-parameters-in-expression-syntax" target="_blank" rel="noopener">Trivia: Type parameters in expression syntax</a></h5><p>We often get the question of why a method with type parameters cannot be called as <code>method&lt;String&gt;(x)</code>. The error messages the compiler gives are not very helpful. However, there is a simple reason for that: the above code is parsed as if both <code>&lt;</code> and <code>&gt;</code> were binary operators, yielding <code>(method &lt; String) &gt; (x)</code>.</p>
</blockquote>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
