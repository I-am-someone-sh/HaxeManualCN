<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Haxe 中文手册 |  </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"3.类型系统/3.7.模块和路径/3.7.3.解析顺序.html","title":""},"data":{"navigation":{"logo":{"text":"Haxe 中文手册","type":"link","path":"index.html"},"main":[{"text":"目录","type":"label","children":null},{"text":"2.类型","type":"link","path":"2.类型/2.类型.html","children":[{"text":"2.1.基本类型","type":"link","path":"2.类型/2.1.基本类型/2.1.基本类型.html","children":[{"text":"2.1.1.数值类型","type":"link","path":"2.类型/2.1.基本类型/2.1.1.数值类型.html"},{"text":"2.1.2.溢出","type":"link","path":"2.类型/2.1.基本类型/2.1.2.溢出.html"},{"text":"2.1.3.数值运算符","type":"link","path":"2.类型/2.1.基本类型/2.1.3.数值运算符.html"},{"text":"2.1.4.Bool类型","type":"link","path":"2.类型/2.1.基本类型/2.1.4.Bool类型.html"},{"text":"2.1.5.Void类型","type":"link","path":"2.类型/2.1.基本类型/2.1.5.Void类型.html"}]},{"text":"2.2.为空性","type":"link","path":"2.类型/2.2.为空性/2.2.为空性.html","children":[{"text":"2.2.1.可选参数和为空性","type":"link","path":"2.类型/2.2.为空性/2.2.1.可选参数和为空性.html"}]},{"text":"2.3.类实例","type":"link","path":"2.类型/2.3.类实例/2.3.类实例.html"},{"text":"2.4.枚举实例","type":"link","path":"2.类型/2.3.类实例/2.4.枚举实例.html"},{"text":"2.5.匿名结构","type":"link","path":"2.类型/2.5.匿名结构/2.5.匿名结构.html","children":[{"text":"2.5.1.结构值的JSON形式","type":"link","path":"2.类型/2.5.匿名结构/2.5.1.结构值的JSON形式.html"},{"text":"2.5.2.结构类型的类记法","type":"link","path":"2.类型/2.5.匿名结构/2.5.2.结构类型的类记法.html"},{"text":"2.5.3.可选字段","type":"link","path":"2.类型/2.5.匿名结构/2.5.3.可选字段.html"},{"text":"2.5.4.性能影响","type":"link","path":"2.类型/2.5.匿名结构/2.5.4.性能影响.html"},{"text":"2.5.5.扩展","type":"link","path":"2.类型/2.5.匿名结构/2.5.5.扩展.html"}]},{"text":"2.6.函数类型","type":"link","path":"2.类型/2.6.函数类型/2.6.函数类型.html"},{"text":"2.7.动态类型","type":"link","path":"2.类型/2.7.动态类型/2.7.动态类型.html"},{"text":"2.8.抽象类型","type":"link","path":"2.类型/2.8.抽象类型/2.8.抽象类型.html"},{"text":"2.9.单形","type":"link","path":"2.类型/2.9.单形/2.9.单形.html"}]},{"text":"3.类型系统","type":"link","path":"3.类型系统/3.类型系统.html","children":[{"text":"3.1.Typedef","type":"link","path":"3.类型系统/3.1.Typedef/3.1.Typedef.html"},{"text":"3.2.类型参数","type":"link","path":"3.类型系统/3.2.类型参数/3.2.类型参数.html"},{"text":"3.3.泛型","type":"link","path":"3.类型系统/3.3.泛型/3.3.泛型.html"},{"text":"3.4.变异","type":"link","path":"3.类型系统/3.4.变异/3.4.变异.html"},{"text":"3.5.一致性检查","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.一致性检查.html","children":[{"text":"3.5.1.类与接口","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.1.类与接口.html"},{"text":"3.5.2.结构子类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.2.结构子类型.html"},{"text":"3.5.3.单形","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.3.单形.html"},{"text":"3.5.4.函数返回","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.4.函数返回.html"},{"text":"3.5.5.通用基本类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.5.通用基本类型.html"}]},{"text":"3.6.类型推断","type":"link","path":"3.类型系统/3.6.类型推断/3.6.类型推断.html"},{"text":"3.7.模块和路径","type":"link","path":"3.类型系统/3.7.模块和路径/3.7.模块和路径.html"}]},{"text":"4.类字段","type":"link","path":"4.类字段/4.类字段.html"},{"text":"5.表达式","type":"link","path":"5.表达式/5.表达式.html"},{"text":"6.语言特性","type":"link","path":"6.语言特性/6.语言特性.html"},{"text":"7.编译器用法","type":"link","path":"7.编译器用法/7.编译器用法.html"},{"text":"8.编译器功能","type":"link","path":"8.编译器功能/8.编译器功能.html"},{"text":"9.宏","type":"link","path":"9.宏/9.宏.html"},{"text":"10.标准库","type":"link","path":"10.标准库/10.标准库.html"},{"text":"支持与反馈","type":"label","children":null},{"text":"Repository Link","type":"link","path":"https://github.com/NulllStack/HaxeManualCN"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Haxe 中文手册</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="3-7-3-解析顺序"><a href="#3-7-3-解析顺序" class="headerlink" title="3.7.3.解析顺序"></a>3.7.3.解析顺序</h1><p>解析顺序一被引入就涉及到不受限制的标识符 。如 foo()，foo=1，foo.field等这些是表达式（第5章）。特别是最后一个包括类似 haxe.ds.StringMap的模块路径，haxe是一个绝对的标识符。</p>
<blockquote>
<p>Resolution order comes into play as soon as unqualiﬁed identiﬁers are involved. These are expressions(5)intheformoffoo(),foo = 1andfoo.field. The last one in particular includes module paths such as haxe.ds.StringMap, where haxe is an unqualiﬁed identiﬁer.</p>
</blockquote>
<p>我们描述解析顺序的算法，取决于以下的状态：</p>
<blockquote>
<p>We describe the resolution order algorithm here, which depends on the following state:</p>
</blockquote>
<ul>
<li>声明的局部变量（第5.10节）（包括函数参数）</li>
<li>导入（第3.7.2节）的模块，类型和静态字段</li>
<li>可用的静态扩展（第6.3节）</li>
<li>当前字段的种类（static或者成员）</li>
<li>当前类及其父类声明的成员字段</li>
<li>当前类声明的静态字段</li>
<li>预期的类型（第3.6.1节）</li>
<li>untyped或者不是untyped的表达式</li>
</ul>
<blockquote>
<ul>
<li>the declared local variables (5.10) (including function arguments)</li>
<li>the imported (3.7.2) modules, types and statics</li>
<li>the available static extensions (6.3)</li>
<li>the kind (static or member) of the current ﬁeld</li>
<li>the declared member ﬁelds on the current class and its parent classes</li>
<li>the declared static ﬁelds on the current class</li>
<li>the expected type (3.6.1)</li>
<li>the expression being untyped or not</li>
</ul>
</blockquote>
<p>给定一个标识符 i ，算法规则如下：</p>
<blockquote>
<p>Given an identiﬁer i, the algorithm is as follows:</p>
</blockquote>
<ol>
<li>如果i 是true，false，this，super或者null，解析到匹配的 常量并停止</li>
<li>如果一个局部变量命名为 i为可访问的，解析它并停止</li>
<li>如果当前的字段是静态的，跳到6</li>
<li>如果当前的类或者任何它的父类有一个字段命名为 i，解析到它并停止</li>
<li>如果一个静态扩展带有第一个当前类类型的参数可用，解析到它并停止</li>
<li>如果当前的类有一个静态字段命名为 i，解析到它并停止</li>
<li>如果一个枚举构造函数命名为i声明在一个导入的枚举，解析到它并停止</li>
<li>如果一个静态方法 i 被显式导入，解析到它并停止</li>
<li>如果i通过一个小写字母开始，跳到11</li>
<li>如果类型名为 i 是可用的，解析到它并停止</li>
<li>如果表达式不是 untyped模式，跳到14</li>
<li>如果i和这个相等，解析到这个常量并停止</li>
<li>产生一个局部变量命名为 i，解析到它并停止</li>
<li>失败</li>
</ol>
<blockquote>
<ol>
<li>If i is true, false, this, super or null, resolve to the matching constant and halt.</li>
<li>If a local variable named i is accessible, resolve to it and halt.</li>
<li>If the current ﬁeld is static, go to 6.</li>
<li>If the current class or any of its parent classes has a ﬁeld named i, resolve to it and halt.</li>
<li>If a static extension with a ﬁrst argument of the type of the current class is available,resolve to it and halt.</li>
<li>If the current class has a static ﬁeld named i, resolve to it and halt.</li>
<li>If an enum constructor named i is declared on an imported enum, resolve to it and halt.</li>
<li>If a static named i is explicitly imported, resolve to it and halt.</li>
<li>If i starts with a lower-case character, go to 11.</li>
<li>If a type named i is available, resolve to it and halt.</li>
<li>If the expression is not in untyped mode, go to 14</li>
<li>If i equals <strong>this</strong>, resolve to the this constant and halt.</li>
<li>Generate a local variable named i, resolve to it and halt.</li>
<li>Fail</li>
</ol>
</blockquote>
<p>对于第10步，也需要定义类型的解析顺序：</p>
<blockquote>
<p>For step 10, it is also necessary to deﬁne the resolution order of types:</p>
</blockquote>
<ol>
<li>如果一个类型名为 i 被导入（直接或者作为模块的部分导入），解析到它并停止</li>
<li>如果当前的包包含一个模块名为 i和类型名为i，解析到它并停止</li>
<li>如果一个类型名为i在顶层可用，解析到它并停止</li>
<li>失败</li>
</ol>
<blockquote>
<ol>
<li>If a type named i is imported (directly or as part of a module), resolve to it and halt.</li>
<li>If the current package contains a module named i with a type named i, resolve to it and halt.</li>
<li>If a type named i is available at top-level, resolve to it and halt.</li>
<li>Fail</li>
</ol>
</blockquote>
<p>对于这个算法的第一步，和之前的第5部第7步，导入决议的顺序很重要：</p>
<blockquote>
<p>For step 1 of this algorithm as well as steps 5 and 7 of the previous one, the order of import resolution is important:</p>
</blockquote>
<ul>
<li>导入的模块和静态扩展从底部到头部检查，第一个匹配的被采用</li>
<li>在一个给定模块，类型从头至尾检查</li>
<li>对于导入，如果名字相同则为匹配</li>
<li>对于静态扩展（第6.3节），如果名字相同并且第一个参数统一（第3.5节）则为匹配。在一个给定类型中被用作静态扩展的字段从头至尾进行检查。</li>
</ul>
<blockquote>
<ul>
<li>Imported modules and static extensions are checked from bottom to top with the ﬁrst match being picked.</li>
<li>Within a given module, types are checked from top to bottom.</li>
<li>For imports, a match is made if the name equals.</li>
<li>For static extensions (6.3), a match is made if the name equals and the ﬁrst argument uniﬁes  (3.5). Within a given type being used as static extension, the ﬁelds are checked from top to bottom.</li>
</ul>
</blockquote>
<p><img src="../../images/3.7.3.png" alt="3.7.3"></p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
