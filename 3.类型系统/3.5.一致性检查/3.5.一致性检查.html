<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Haxe 中文手册 |  </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"3.类型系统/3.5.一致性检查/3.5.一致性检查.html","title":""},"data":{"navigation":{"logo":{"text":"Haxe 中文手册","type":"link","path":"index.html"},"main":[{"text":"目录","type":"label","children":null},{"text":"2.类型","type":"link","path":"2.类型/2.类型.html","children":[{"text":"2.1.基本类型","type":"link","path":"2.类型/2.1.基本类型/2.1.基本类型.html","children":[{"text":"2.1.1.数值类型","type":"link","path":"2.类型/2.1.基本类型/2.1.1.数值类型.html"},{"text":"2.1.2.溢出","type":"link","path":"2.类型/2.1.基本类型/2.1.2.溢出.html"}]},{"text":"2.2.为空性","type":"link","path":"2.类型/2.2.为空性/2.2.为空性.html"},{"text":"2.3.类实例","type":"link","path":"2.类型/2.3.类实例/2.3.类实例.html"},{"text":"2.4.枚举实例","type":"link","path":"2.类型/2.3.类实例/2.4.枚举实例.html"},{"text":"2.5.匿名结构","type":"link","path":"2.类型/2.5.匿名结构/2.5.匿名结构.html","children":[{"text":"2.5.1.结构值的JSON形式","type":"link","path":"2.类型/2.5.匿名结构/2.5.1.结构值的JSON形式.html"},{"text":"2.5.2.结构类型的类记法","type":"link","path":"2.类型/2.5.匿名结构/2.5.2.结构类型的类记法.html"},{"text":"2.5.3.可选字段","type":"link","path":"2.类型/2.5.匿名结构/2.5.3.可选字段.html"},{"text":"2.5.4.性能影响","type":"link","path":"2.类型/2.5.匿名结构/2.5.4.性能影响.html"},{"text":"2.5.5.扩展","type":"link","path":"2.类型/2.5.匿名结构/2.5.5.扩展.html"}]},{"text":"2.6.函数类型","type":"link","path":"2.类型/2.6.函数类型/2.6.函数类型.html"},{"text":"2.7.动态类型","type":"link","path":"2.类型/2.7.动态类型/2.7.动态类型.html"},{"text":"2.8.抽象类型","type":"link","path":"2.类型/2.8.抽象类型/2.8.抽象类型.html"},{"text":"2.9.单形","type":"link","path":"2.类型/2.9.单形/2.9.单形.html"}]},{"text":"3.类型系统","type":"link","path":"3.类型系统/3.类型系统.html","children":[{"text":"3.1.Typedef","type":"link","path":"3.类型系统/3.1.Typedef/3.1.Typedef.html"},{"text":"3.2.类型参数","type":"link","path":"3.类型系统/3.2.类型参数/3.2.类型参数.html"},{"text":"3.3.泛型","type":"link","path":"3.类型系统/3.3.泛型/3.3.泛型.html"},{"text":"3.4.变异","type":"link","path":"3.类型系统/3.4.变异/3.4.变异.html"},{"text":"3.5.一致性检查","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.一致性检查.html","children":[{"text":"3.5.1.类与接口","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.1.类与接口.html"},{"text":"3.5.2.结构子类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.2.结构子类型.html"},{"text":"3.5.3.单形","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.3.单形.html"},{"text":"3.5.4.函数返回","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.4.函数返回.html"},{"text":"3.5.5.通用基本类型","type":"link","path":"3.类型系统/3.5.一致性检查/3.5.5.通用基本类型.html"}]},{"text":"3.6.类型推断","type":"link","path":"3.类型系统/3.6.类型推断/3.6.类型推断.html"},{"text":"3.7.模块和路径","type":"link","path":"3.类型系统/3.7.模块和路径/3.7.模块和路径.html"}]},{"text":"支持与反馈","type":"label","children":null},{"text":"Repository Link","type":"link","path":"https://github.com/NulllStack/HaxeManualCN"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Haxe 中文手册</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="3-5-一致性检查"><a href="#3-5-一致性检查" class="headerlink" title="3.5.一致性检查"></a>3.5.一致性检查</h1><p>一致性检查 是 Haxe 类型系统的核心，其为Haxe程序极大地提升了健壮性（或称鲁棒性）。它描述了某一个类型与另一个类型是否兼容的过程。</p>
<blockquote>
<p>Uniﬁcation is the heart of the type system and contributes immensely to the robustness of Haxe programs. It describes the process of checking if a type is compatible to another type.</p>
</blockquote>
<p><strong>一致性检查</strong></p>
<blockquote>
<p>定义：一致性<br>类型A 与类型 B 之间的一致性检查是一个定向过程，它会回答一个问题：A 是否可以被赋值给 B。当两者中有一个 是/含有 单形（monomorph) (2.9) 时，其类型将在一致性检查过程中产生畸变（mutate）</p>
<p>[warning] Deﬁnition: Uniﬁcation<br>Uniﬁcation between two types A and B is a directional process which answers the question if A can be assigned to B. It may mutate either type if it is or has a monomorph (2.9).</p>
</blockquote>
<p>一致性错误非常容易被触发：</p>
<blockquote>
<p>Uniﬁcation errors are very easy to trigger:</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">        <span class="comment">// Int should be String </span></span><br><span class="line">        <span class="keyword">var</span> s:<span class="type">String </span>= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们尝试分配一个 <code>Int</code> 类型的值给一个 <code>String</code> 类型变量时，会导致编译器尝试 <strong>把 <code>Int</code> 统一为 <code>String</code></strong>。当然，这是不允许的并且会使编译器发出一个错误 “Int should be String”。</p>
<blockquote>
<p>We try to assign a value of type Int to a variable of type String, which causes the compiler to try and unify Int with String. This is, of course, not allowed and makes the compiler emit the error Int should be String.</p>
</blockquote>
<p>在这个特殊的例子中，一致性检查在 <strong>赋值</strong> 操作时被触发，前文中的 “…是否可以被赋值给…” 的定义在此例中很直观，但这只是会执行一致性检查的其中一例：</p>
<blockquote>
<p>In this particular case, the uniﬁcation is triggered by an assignment, a context in which the “is assignable to” deﬁnition is intuitive. It is one of several cases where uniﬁcation is performed:</p>
</blockquote>
<p><strong>赋值</strong>：如果 a 被分配给 b，类型 a 会统一为 类型 b 。</p>
<blockquote>
<p><strong>Assignment</strong>: If <code>a</code> is assigned to <code>b</code>, the type of <code>a</code> is uniﬁed with the type of <code>b</code>.</p>
</blockquote>
<p><strong>函数调用</strong>：我们在介绍 函数类型 时已经看过一个简要的例子了。通常，编译器会尝试把第一个实际参数的类型统一为第一个形式参数的类型、把第二个实际参数类型统一为第二个形式参数的类型…以此类推。</p>
<blockquote>
<p><strong>Function call</strong>: We have brieﬂy seen this one while introducing thefunction(2.6)type. In general, the compiler tries to unify the ﬁrst given argument type with the ﬁrst expected argument type, the second given argument type with the second expected argument type and so on until all argument types are handled.</p>
</blockquote>
<p><strong>函数返回</strong>：不论函数何时出现 <code>return e</code> 表达式，<code>e</code> 的类型都会被统一为函数的返回类型。如果函数没有显式地声明返回类型，则返回类型会被推断为 <code>e</code> 的类型 且 随后的 <code>return</code> 表达式都会以该类型进行推断。</p>
<blockquote>
<p><strong>Function return</strong>: Whenever a function hasa return e expression, thetypeof e is uniﬁed with the function return type. If the function has no explicit return type,it is inferred to the type of e and subsequent <code>return</code> expressions are inferred against it.</p>
</blockquote>
<p><strong>数组声明</strong>：编译器会尝试在一个数组声明的所有给定的类型中寻找一个最小化类型。请参阅 通用基本类型（第3.5.5节）了解更多细节。</p>
<blockquote>
<p><strong>Array declaration:</strong> The compiler tries to ﬁnd a minimal type between all given types in an array declaration. Refer to Common Base Type (Section 3.5.5) for details.</p>
</blockquote>
<p><strong>对象声明</strong>：如果一个对象被分配了一个与声明时所不同的类型，那么编译器会把所有给定类型的字段的类型统一为期望类型的字段的类型。</p>
<blockquote>
<p><strong>Object declaration</strong>: If an object is declared “against” a given type, the compiler uniﬁes each given ﬁeld type with each expected ﬁeld type.</p>
</blockquote>
<p><strong>操作符一致性检查</strong>：某一操作符会期望作用于某一种类型上，当操作符作用于某一类型时该类型会被统一为操作符期望的类型，比如，表达式 <code>a &amp;&amp; b</code> 会把 <code>a</code> 和 <code>b</code> 都统一为 <code>Bool</code> 类型， 而表达式 <code>a == b</code> 会把 <code>a</code> 统一为 <code>b</code>。</p>
<blockquote>
<p><strong>Operator uniﬁcation</strong>: Certain operators expect certain types which the given types are uniﬁed against. For instance, the expression a &amp;&amp; b uniﬁes both a and b with Bool and the expression a == b uniﬁes a with b.</p>
</blockquote>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
